name: Deploy to k3s Cluster

on:
  workflow_run:
    workflows: ["Frontend CI", "Build and Analyze"]
    types: [completed]
    branches: [main, dev]
  push:
    branches: [main, dev]
    paths:
      - 'infra/**'
  workflow_dispatch:

concurrency:
  group: k3s-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-k3s:
    name: Deploy to k3s
    runs-on: self-hosted
    permissions:
      contents: read
      id-token: write
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}

    steps:
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð Ð•ÐŸÐž â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout repository
        uses: actions/checkout@v4

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð›ÐžÐ“Ð†ÐšÐ / Ð†ÐÐ¡Ð¢Ð Ð£ÐœÐ•ÐÐ¢Ð˜ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Display Location Variables
        run: |
          echo "::notice title=Location Check::Using REGION: ${{ secrets.GCP_REGION }}"
          echo "::notice title=Location Check::Using ZONE:   ${{ secrets.GCP_ZONE }}"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.2
          terraform_wrapper: false

      - name: Set up tools (curl, kubectl, helm)
        run: |
          sudo apt-get update -qq

          command -v curl   >/dev/null || sudo apt-get install -y curl
          command -v kubectl>/dev/null || {
            curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          }
          command -v helm   >/dev/null || curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Install Google Cloud CLI
        timeout-minutes: 10
        run: |
          if ! command -v gcloud &>/dev/null; then
            sudo apt-get remove -y google-cloud-cli google-cloud-sdk || true
            sudo rm -f /etc/apt/sources.list.d/google-cloud-sdk.list /usr/share/keyrings/cloud.google.gpg
            sudo apt-get update -qq
            sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
            echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" \
              | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
            curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
            sudo apt-get update -qq && sudo apt-get install -y google-cloud-cli
          fi
          gcloud --version

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account:            ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          project_id:                 ${{ secrets.GCP_PROJECT_ID }}

      - name: Set up Google Cloud CLI with Authentication
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin'

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ GCS bucket Ð´Ð»Ñ backend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Create or Verify GCS State Bucket
        run: |
          BUCKET="${{ secrets.GCS_BUCKET_NAME }}"
          REGION="${{ secrets.GCP_REGION }}"

          if ! gcloud storage buckets describe "gs://$BUCKET" &>/dev/null; then
            gcloud storage buckets create "gs://$BUCKET" \
              --location="$REGION" --uniform-bucket-level-access
            gcloud storage buckets update "gs://$BUCKET" --versioning
            gcloud storage buckets add-iam-policy-binding "gs://$BUCKET" \
              --member="serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}" \
              --role="roles/storage.objectAdmin"
          fi
          gcloud storage ls "gs://$BUCKET/"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Terraform vars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Setup terraform.tfvars
        run: |
          cat > infra/terraform/gcp/terraform.tfvars << EOF
          project_id            = "${{ secrets.GCP_PROJECT_ID }}"
          region                = "${{ secrets.GCP_REGION }}"
          zone                  = "${{ secrets.GCP_ZONE }}"
          ssh_user              = "${{ secrets.GCP_SSH_USER }}"
          ssh_public_key_content= "${{ secrets.GCP_SSH_PUBLIC_KEY }}"
          bucket_name           = "${{ secrets.GCS_BUCKET_NAME }}"
          service_account_email = "${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}"
          cloudflare_api_token  = "${{ secrets.CLOUDFLARE_API_TOKEN }}"
          cloudflare_zone_id    = "${{ secrets.CLOUDFLARE_ZONE_ID }}"
          EOF

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Terraform apply â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy Infrastructure
        working-directory: infra/terraform/gcp
        run: |
          cat > backend.conf <<EOF
          bucket = "${{ secrets.GCS_BUCKET_NAME }}"
          prefix = "terraform/state"
          EOF

          terraform init -backend-config=backend.conf
          terraform apply -auto-approve -var-file="terraform.tfvars"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÑƒÑ”Ð¼Ð¾ kubeconfig â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Setup k3s cluster
        working-directory: infra/terraform/gcp
        timeout-minutes: 15
        run: |
          rm -f ~/.kube/config
          for i in {1..20}; do
            gcloud storage cp gs://${{ secrets.GCS_BUCKET_NAME }}/k3s-kubeconfig ~/.kube/config && break
            echo "Kubeconfig not yet available, retrying in 20 s ($i/20)"; sleep 20
          done

          if [ ! -f ~/.kube/config ]; then
            echo "::error::Failed to download kubeconfig"; exit 1
          fi

          # ðŸ‘‰â€‚Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ”Ð¼Ð¾ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¸Ð¹ Ñ„Ð°Ð¹Ð»
          export KUBECONFIG="$HOME/.kube/config"
          echo "KUBECONFIG=$KUBECONFIG" >>"$GITHUB_ENV"

          echo "Waiting for API to become readyâ€¦"

          for i in {1..20}; do                      # ~5 min
            kubectl get --raw=/readyz >/dev/null 2>&1 && break
            echo " â†ª  API not ready, retryingâ€¦ ($i/20)"; sleep 15
          done

          echo "Verifying cluster connectivityâ€¦"
          kubectl get nodes

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Helm deploy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy applications with Helm
        env:
          FRONTEND_IMAGE: "ghcr.io/${{ github.repository }}-frontend:${{ github.event.workflow_run.head_sha || github.sha }}"
          BACKEND_IMAGE:  "ghcr.io/${{ github.repository }}:${{ github.event.workflow_run.head_sha || github.sha }}"
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            NS="prod"; ENV="prod"
          else
            NS="dev";  ENV="dev"
          fi

          kubectl create namespace $NS --dry-run=client -o yaml | kubectl apply -f -

          helm upgrade --install database ./helm/database \
            --namespace $NS --values environments/$ENV/database-values.yaml --wait

          helm upgrade --install backend ./helm/backend \
            --namespace $NS --values environments/$ENV/backend-values.yaml  --wait

          helm upgrade --install frontend ./helm/frontend \
            --namespace $NS --values environments/$ENV/frontend-values.yaml --wait

          kubectl get all -n $NS
          kubectl get ingress -n $NS

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Argo CD (GitOps) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Setup ArgoCD
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
          echo "ArgoCD admin password: $(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d)"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ð¢Ñ€Ð¸Ð³ÐµÑ€ GitOps workflow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Trigger GitOps Workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ref = process.env.GITHUB_REF || '${{ github.ref }}';
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              workflow_id: 'cd-gitops.yml',
              ref
            });
            console.log(`Triggered cd-gitops.yml for ref: ${ref}`);