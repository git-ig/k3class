name: Deploy to k3s Cluster

on:
  workflow_run:
    workflows: ["Frontend CI", "Build and Analyze"]
    types: [completed]
    branches: [main, dev]
  push:
    branches: [main, dev]
    paths:
      - 'infra/**'
  workflow_dispatch:

concurrency:
  group: k3s-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-k3s:
    name: Deploy to k3s
    runs-on: self-hosted
    permissions:
      contents: read
      id-token: write
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.2
          terraform_wrapper: false

      - name: Set up tools
        run: |
          # Check and install curl if not present (direct download)
          if ! command -v curl &> /dev/null; then
            echo "Installing curl..."
            sudo apt install curl
          else
            echo "curl is already installed, skipping."
          fi
          
          # Check and install kubectl if not present (direct download)
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          else
            echo "kubectl is already installed, skipping."
          fi
          
          # Check and install Helm if not present
          if ! command -v helm &> /dev/null; then
            echo "Installing Helm..."
            curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          else
            echo "Helm is already installed, skipping."
          fi

      - name: Install Google Cloud CLI
        timeout-minutes: 10  # Increased to handle potential network delays
        run: |
            if command -v gcloud &> /dev/null; then
              echo "Google Cloud CLI is already installed, skipping installation."
            else
              echo "Google Cloud CLI not found, proceeding with installation."
              
              # Clean up any existing Google Cloud SDK installations and repo files to avoid duplicates
              sudo apt remove -y google-cloud-sdk google-cloud-cli || true
              sudo rm -f /etc/apt/sources.list.d/google-cloud-sdk.list
              sudo rm -f /usr/share/keyrings/cloud.google.gpg
              
              # Install prerequisites
              sudo apt-get update -qq
              sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
              
              # Add Google Cloud SDK apt repository
              echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
              
              # Download and dearmor the key
              curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
              
              # Update and install with added verbosity for debugging
              echo "Starting apt update..."
              sudo apt update
              echo "Starting apt install..."
              sudo apt install -y --no-install-recommends google-cloud-cli
            fi
            
            # Verify installation (always run)
            gcloud --version || echo "Installation failed or verification error"
        
        
        
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }} 
          # token_format: 'access_token'
          project_id: ${{ secrets.GCP_PROJECT_ID }}
      
      - name: Set up Google Cloud CLI with Authentication
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin'  # Optional: Add if needed for Kubernetes/GKE/K3s auth
          
      - name: Verify Authentication
        run: |
          gcloud auth list || echo "Authentication failed"
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}  # Optional: Set project if not already configured
  
      - name: Debug Permissions
        run: |
          # Показати активний акаунт
          gcloud auth list
          
          # Перевірити IAM політики для сервіс-акаунта
          gcloud projects get-iam-policy ${{ secrets.GCP_PROJECT_ID }} --filter="bindings.members:serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT }}"
          
          # Тест на дозвіл створення бакета (спроба створення тестового, потім видалення)
          TEST_BUCKET="test-bucket-$(date +%s)"
          gcloud storage buckets create gs://$TEST_BUCKET --location=${{ secrets.GCP_REGION }} && gcloud storage buckets delete gs://$TEST_BUCKET --force || echo "Failed to create test bucket - permission issue"

      - name: Create or Verify GCS State Bucket
        run: |
            BUCKET_NAME="${{ secrets.GCS_BUCKET_NAME }}"
            REGION="${{ secrets.GCP_REGION }}"
        
            # Debug: Show current auth and permissions
            gcloud auth list
            gcloud projects get-iam-policy ${{ secrets.GCP_PROJECT_ID }} --filter="bindings.role:roles/storage.admin"
        
            # Check if bucket exists
            if gcloud storage buckets describe gs://$BUCKET_NAME &> /dev/null; then
              echo "Bucket $BUCKET_NAME already exists, skipping creation."
            else
              echo "Creating bucket $BUCKET_NAME..."
              gcloud storage buckets create gs://$BUCKET_NAME --location=$REGION --uniform-bucket-level-access
              
              # Enable versioning
              gcloud storage buckets update gs://$BUCKET_NAME --versioning
              
              # Add IAM for service account
              gcloud storage buckets add-iam-policy-binding gs://$BUCKET_NAME \
                --member=serviceAccount:${{ secrets.GCP_SERVICE_ACCOUNT }} \
                --role=roles/storage.objectAdmin
            fi
            
            # Verify access
            gcloud storage ls gs://$BUCKET_NAME/ || echo "Failed to access bucket - check logs"
        

      - name: Setup terraform.tfvars
        run: |
          # Create terraform.tfvars (no SSH keys needed)
          cat > infra/terraform/gcp/terraform.tfvars << EOF
          project_id               = "${{ secrets.GCP_PROJECT_ID }}"
          region                   = "${{ secrets.GCP_REGION }}"
          zone                     = "${{ secrets.GCP_ZONE }}"
          ssh_user                 = "${{ secrets.GCP_SSH_USER }}"  # Keep if needed for other purposes, but not used for keys
          bucket_name              = "${{ secrets.GCS_BUCKET_NAME }}"
          service_account_email    = "${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}"
          cloudflare_api_token     = "${{ secrets.CLOUDFLARE_API_TOKEN }}"
          cloudflare_zone_id       = "${{ secrets.CLOUDFLARE_ZONE_ID }}"
          EOF

      - name: Deploy Infrastructure
        working-directory: infra/terraform/gcp
        run: |
          # Create backend config
          echo "bucket = \"${{ secrets.GCS_BUCKET_NAME }}\"" > backend.conf
          echo "prefix = \"terraform/state\"" >> backend.conf

          # Initialize and apply
          terraform init -backend-config=backend.conf
          terraform apply -auto-approve -var-file="terraform.tfvars"

      - name: Setup k3s cluster
        run: |
          # Get IPs from Terraform
          cd infra/terraform/gcp
          CONTROL_PLANE_IP=$(terraform output -raw k3s_control_plane_public_ip)
          WORKER_IPS=$(terraform output -json k3s_worker_private_ips | jq -r '.[]')

          # Wait for cluster to be ready (installation via startup scripts in Terraform)
          sleep 300  # Increased for reliability; adjust based on tests

          # Download kubeconfig from GCS with retry
          for i in {1..5}; do
            gcloud storage cp gs://${{ secrets.GCS_BUCKET_NAME }}/k3s-kubeconfig ~/.kube/config && break
            echo "Kubeconfig not found, retrying in 30s..."
            sleep 30
          done
          if [ ! -f ~/.kube/config ]; then
            echo "Error: Failed to download kubeconfig"
            exit 1
          fi
          sed -i "s/127.0.0.1/$CONTROL_PLANE_IP/g" ~/.kube/config

          # Verify cluster
          kubectl get nodes

      - name: Deploy applications with Helm
        env:
          FRONTEND_IMAGE: "ghcr.io/${{ github.repository }}-frontend:${{ github.event.workflow_run.head_sha || github.sha }}"
          BACKEND_IMAGE: "ghcr.io/${{ github.repository }}:${{ github.event.workflow_run.head_sha || github.sha }}"
        run: |
          # Set environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            NAMESPACE="prod"
            ENV="prod"
          else
            NAMESPACE="dev"
            ENV="dev"
          fi

          # Create namespace
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

          # Deploy database
          helm upgrade --install database ./helm/database \
            --namespace $NAMESPACE \
            --values environments/$ENV/database-values.yaml \
            --wait

          # Deploy backend (fixed values path)
          helm upgrade --install backend ./helm/backend \
            --namespace $NAMESPACE \
            --values environments/$ENV/backend-values.yaml \
            --wait

          # Deploy frontend
          helm upgrade --install frontend ./helm/frontend \
            --namespace $NAMESPACE \
            --values environments/$ENV/frontend-values.yaml \
            --wait

          # Verify deployments
          kubectl get all -n $NAMESPACE
          kubectl get ingress -n $NAMESPACE

      - name: Setup ArgoCD
        run: |
          # Install ArgoCD for GitOps
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

          # Wait for ArgoCD to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

          # Get initial admin password
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "ArgoCD admin password: $ARGOCD_PASSWORD"
          
      - name: Trigger GitOps Workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ref = process.env.GITHUB_REF || '${{ github.ref }}';
            const response = await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'cd-gitops.yml',
              ref: ref
            });
            console.log(`Triggered cd-gitops.yml workflow for ref: ${ref}`);
